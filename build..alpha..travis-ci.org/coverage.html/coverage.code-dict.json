{"/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/test.js":"/* istanbul instrument in package npmtest_elasticsearch_odm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/lib.npmtest_elasticsearch_odm.js":"/* istanbul instrument in package npmtest_elasticsearch_odm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_elasticsearch_odm = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_elasticsearch_odm = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-elasticsearch-odm && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_elasticsearch_odm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_elasticsearch_odm\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_elasticsearch_odm.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_elasticsearch_odm.rollup.js'] =\n            local.assetsDict['/assets.npmtest_elasticsearch_odm.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_elasticsearch_odm.__dirname + '/lib.npmtest_elasticsearch_odm.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/index.js":"'use strict';\n\nvar logger = require('./lib/logger'),\n    Client = require('./lib/client'),\n    Schema = require('./lib/schema'),\n    errors = require('./lib/errors'),\n    pluralize = require('pluralize'),\n    utils = require('./lib/utils'),\n    MissingArgumentError = errors.MissingArgumentError,\n    ConnectionError = errors.ConnectionError,\n    Model = require('./lib/model'),\n    defaultMethods = require('./lib/default-methods'),\n    defaultMappings = require('./default-mappings'),\n    _ = require('lodash'),\n    Promise = require('bluebird');\n\nlogger.transports.console.silent = (process.env.NODE_ENV !== 'development');\n\nvar db = {\n  host: 'localhost:9200',\n  index: '',\n  logging: process.env.NODE_ENV === 'development',\n  client: {},\n  models: {}\n};\n\nvar CONNECTED = false;\n\nvar mappingQueue = [];\nvar syncMapping = true;\nvar handleMappingQueue = function(){\n  if(!mappingQueue.length || syncMapping == false) return Promise.resolve();\n  return Promise.map(mappingQueue , function(v){\n    return db.client.indices.putMapping({\n      index: db.index,\n      type: v.type,\n      ignore_conflicts: true,\n      body:v.mapping\n    });\n  });\n};\n\nfunction connect(options){\n  if(isConnected()) return Promise.resolve();\n\n  // can pass just the index name, or a client configuration object.\n  if(_.isString(options)){\n    db.index = options;\n  }else if(_.isObject(options)){\n    if(!options.index) return Promise.reject(new MissingArgumentError('options.index'));\n    if(options.hasOwnProperty('syncMapping')){\n      syncMapping = options.syncMapping;\n      delete options.syncMapping;\n    }\n    db = _.assign(db, options);\n  }else{\n    return Promise.reject(new MissingArgumentError('options'));\n  }\n\n  module.exports.client = db.client = Client.makeClient(db);\n\n  return db.client.indices.exists({index: db.index}).then(function(result){\n    //No error - connected\n    CONNECTED = true;\n\n    if(result){\n      return handleMappingQueue();\n    }else{\n      // if the index doesn't exist, then create it.\n      return createIndex(db.index).then(handleMappingQueue);\n    }\n  })\n  .then(function(results){\n    return Promise.resolve();\n  });\n}\n\nfunction isConnected(){\n  return CONNECTED;\n}\n\nfunction status(type){\n  if(!isConnected()) return Promise.reject(new ConnectionError(db.host));\n\n  var args = {index: db.index};\n  if(type) args.type = type;\n  return db.client.indices.status(args);\n}\n\nfunction createIndex(index, mappings){\n  if(!index) return Promise.reject(new MissingArgumentError('index'));\n  if(!isConnected()) return Promise.reject(new ConnectionError(db.host));\n\n  return db.client.indices.create({\n    index: index,\n    body: mappings || defaultMappings\n  });\n}\n\nfunction removeIndex(index){\n  if(!index) return Promise.reject(new MissingArgumentError('index'));\n  if(!isConnected()) return Promise.reject(new ConnectionError(db.host));\n\n  return db.client.indices.delete({index: index}).catch(function(){});\n}\n\nfunction model(modelName, schema){\n  if(!modelName) throw new MissingArgumentError('modelName');\n  if(schema && !(schema instanceof Schema)) throw new errors.ElasticsearchError('Invalid schema for \"'+modelName+'\".');\n\n  if(db.models[modelName]){\n\n    // don't overwrite schemas on secondary calls.\n    if(schema && _.isEmpty(db.models[modelName].model.schema)){\n      db.models[modelName].model.schema = schema;\n    }\n\n    // return model from cache if it exists.\n    return db.models[modelName];\n  }\n\n  // create a neweable function object.\n  function modelInstance(data){\n    var self = this;\n    // Add any user supplied schema instance methods.\n    if(schema){\n      _.assign(self, schema.methods);\n    }\n    Model.call(self, data);\n  }\n  utils.inherits(modelInstance, Model);\n\n  // add crud/query static functions.\n  _.assign(modelInstance, defaultMethods);\n\n  modelInstance.db = db;\n\n  modelInstance.model = {\n    type: pluralize(modelName).toLowerCase(),\n    name: modelName,\n    constructor: modelInstance\n  };\n\n  if(schema) {\n    modelInstance.model.schema = schema;\n    // Add any user supplied schema static methods.\n    _.assign(modelInstance, schema.statics);\n\n    // User can provide their own type name, default is pluralized.\n    if(schema.options.type) modelInstance.model.type = schema.options.type;\n\n    // Update the mapping asynchronously.\n    var mapping = {};\n    mapping[modelInstance.model.type] = schema.toMapping();\n    mappingQueue.push({type: modelInstance.model.type, mapping: mapping});\n    // If we're already connected process the mapping queue.\n    if(isConnected()){\n      handleMappingQueue();\n    }\n  }\n\n  return db.models[modelName] = modelInstance;\n}\n\nfunction stats(){\n  if(!isConnected()) return Promise.reject(new ConnectionError(db.host));\n  return db.client.indices.stats({index:db.index});\n}\n\nmodule.exports = {\n  client: db.client,\n  connect: connect,\n  isConnected: isConnected,\n  status: status,\n  stats: stats,\n  removeIndex: removeIndex,\n  createIndex: createIndex,\n  model: model,\n  Schema: Schema\n};\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/logger.js":"'use-strict';\n\nvar winston = require('winston');\n\nmodule.exports = makeLogger();\n\nfunction makeLogger(){\n\n  winston.addColors({\n    debug: 'green',\n    info: 'cyan',\n    silly: 'purple',\n    trace: 'magenta',\n    verbose: 'magenta',\n    warn: 'yellow',\n    warning: 'yellow',\n    error: 'red'\n  });\n\n  var logger = new winston.Logger({\n    transports: [\n      new(winston.transports.Console)({\n        level: 'silly',\n        handleExceptions: true,\n        prettyPrint: true,\n        silent: false,\n        timestamp: true,\n        colorize: true,\n        json: false\n      })\n    ],\n    exceptionHandlers: [\n      new(winston.transports.Console)({\n        level: 'warn',\n        handleExceptions: true,\n        prettyPrint: true,\n        silent: false,\n        timestamp: true,\n        colorize: true,\n        json: false\n      })\n    ]\n  });\n  logger.setLevels({\n    silly: 0,\n    debug: 1,\n    verbose: 2,\n    trace : 2,\n    info: 3,\n    warn: 4,\n    warning: 4,\n    error: 5\n  });\n\n  return logger;\n}\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/client.js":"'use strict';\n\nvar logger = require('./logger'),\n    _ = require('lodash'),\n    Promise = require('bluebird'),\n    elasticsearch = require('elasticsearch');\n\nmodule.exports.makeClient = function(options){\n  return new elasticsearch.Client(getClientSettings(options));\n};\n\nfunction getClientSettings(options){\n  var clientSettings = {\n    apiVersion: '1.7',\n    keepAlive: true,\n    defer: function () {\n      var resolve, reject;\n      var promise = new Promise(function() {\n        resolve = arguments[0];\n        reject = arguments[1];\n      });\n      return {\n        resolve: resolve,\n        reject: reject,\n        promise: promise\n      };\n    }\n  };\n  if(options.logging) {\n    clientSettings.log = function(){\n      var log = logger;\n      this.error = log.error.bind(log);\n      this.warning = log.warn.bind(log);\n      this.info = log.info.bind(log);\n      this.debug = log.debug.bind(log);\n      this.trace = function (method, req, body, res, status) {\n        var parts = req.path.split('/');\n        var meta = {\n            host : req.protocol + '//' + req.hostname + ':' + req.port,\n            index : options.index,\n            type :  parts[2] || '',\n            response : status,\n            queryString : parts[parts.length-1],\n            queryBody : body || ''\n        };\n        if(status !== 200) {\n          meta.responseBody = res;\n          log.trace('[ELASTICSEARCH] ' + method + ' @ ', meta);\n        }\n      };\n      this.close = function () {  };\n    };\n  }\n  return _.merge(clientSettings, _.omit(options, 'logging'));\n}\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/schema.js":"'use-strict';\n\nvar schemaTypes = require('./schema-types'),\n    errors = require('./errors'),\n    Dot = require('dot-object'),\n    Kareem = require('kareem'),\n    ValidatorError = errors.ValidatorError,\n    ValidationError = errors.ValidationError,\n     _ = require('lodash');\n\n// sets ovverides in dot object\n// see https://github.com/rhalff/dot-object/issues/8\nvar dot = new Dot('.', true);\n\nmodule.exports = Schema;\n\nfunction Schema(schema, options) {\n  this.fields = {};\n  this.methods = {};\n  this.statics = {};\n  if(schema) this.fields = buildFieldsFromSchema(schema).fields;\n\n  this.hooks = new Kareem();\n\n\n  Object.defineProperty(this, 'options', {\n    value: _.merge({}, options),\n    configurable: false,\n    writable: false\n  });\n}\n\nSchema.prototype.toMapping = function() {\n  var properties = {};\n\n  var checkLeaf = function(obj, path){\n    _.forOwn(obj, function(v, k){\n      var currentPath = path ? path + '.' + k : k;\n      if(v.type){\n        var field = {type: v.type.esType};\n        // we extend the type definition with any user supplied options.\n        // these options can be any options listed for Elasticsearch Core Types.\n        // see https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-core-types.html\n        var defaults = {};\n\n        // NOTE: This is opinionated. Setting to not_analyzed doesn't\n        // allow full text search. But since we are trying to be like Mongoose\n        // we assume this is most helpful to users as a default. This option\n        // can still be overridden in the schema.\n        if(v.type.jsType === String) defaults.index = 'not_analyzed';\n\n        _.assign(field, defaults, v.options);\n        dot.str(currentPath, field, properties);\n      }else{\n        // If there is no type, then this is a nested object.\n        // Build an Elasticsearch object mapping with nested properties.\n        dot.str(currentPath, {type: 'object'}, properties);\n        checkLeaf(v, currentPath + '.properties');\n      }\n    });\n  };\n\n  checkLeaf(this.fields);\n\n  return {\n    properties: properties\n  };\n};\n\nSchema.prototype.validate = function(doc, partial) {\n  var errs = [];\n  var self = this;\n\n  var compareWithOptions = function(field, fieldType, path){\n    if(field){\n      if(fieldType.type.compare(field) === false){\n        errs.push(new ValidatorError(path, \"Value '\" + field + \"' Not of type '\" + fieldType.type.esType + '\".'));\n      }\n    }else{\n      if(fieldType.options.required && !partial){\n        errs.push(new ValidatorError(path, 'Required field is missing.'));\n      }\n    }\n  };\n\n  var checkType = function(fieldType, path){\n    var docField = dot.pick(path, doc);\n    // check if it's an array of items or a single value.\n    // check all elements in the array if so.\n    if(_.isArray(docField)){\n      _.forEach(docField, function(v){\n        compareWithOptions(v, fieldType, path);\n      });\n    }else{\n      compareWithOptions(docField, fieldType, path);\n    }\n  };\n\n  var checkLeaf = function(obj, path){\n    _.forOwn(obj, function(v, k){\n      // build a dot notation path to be used with 'dot-object'\n      var currentPath = path ? path + '.' + k : k;\n\n      // if a leaf contains a type property, then it's a type definition\n      // otherwise it's a nested document.\n      if(v.type){\n        if(_.isPlainObject(v.type) && v.type.type){\n          currentPath = currentPath + '.type';\n          v = v.type;\n        }\n        checkType(v, currentPath);\n      }else{\n        checkLeaf(v, currentPath);\n      }\n    });\n  };\n\n  checkLeaf(self.fields);\n\n  if(errs.length){\n    return new ValidationError(self, errs);\n  }else{\n    void 0;\n  }\n};\n\nSchema.prototype.post = function(name, func) {\n  this.hooks.post.apply(this.hooks, arguments);\n  return this;\n};\n\nSchema.prototype.pre = function(name, func) {\n  this.hooks.pre.apply(this.hooks, arguments);\n  return this;\n};\n\nfunction buildFieldsFromSchema(fields){\n\n  var results = {\n    fields: {}\n  };\n\n  Object.keys(fields).forEach(function(v){\n    mapSchemaType(v);\n  });\n\n  function mapSchemaType(key, path) {\n    var currentPath = path ? path + '.' + key : key;\n    var value = dot.pick(currentPath, fields);\n    var schemaType;\n    var typeOptions = {};\n\n    if (_.isPlainObject(value)) {\n\n      if(value.type){\n        typeOptions = _.omit(value, 'type');\n\n        if(_.isArray(value.type)){\n          // advanced type definition, like { name: {type: String} }\n\n          // mapping as an array is just a helper so it's similar to mongoose\n          // elasticsearch doesn't actually care if it's defined as an array.\n          schemaType = findType(value.type[0]);\n        }else if(_.isPlainObject(value.type) && value.type.type){\n          // is the property just called 'type' & not actually a type definition?\n          typeOptions = _.omit(value.type, 'type');\n          currentPath = currentPath + '.type';\n          schemaType = findType(value.type.type);\n        }else{\n          // simple type definition, like {name: String}\n          schemaType = findType(value.type);\n        }\n\n      }else{\n        // it's a nested document, recursively map it too add add to currentPath\n        Object.keys(value).forEach(function(v){\n          mapSchemaType(v, key);\n        });\n      }\n\n    }else if(_.isFunction(value)) {\n      schemaType = findType(value);\n    }else if(_.isArray(value)){\n      // it is either a nested object array, or it's just a type definiton\n      // that has been wrapped in an array element. if it's a nested object\n      // array, then we'll recursively map it's inner types.\n      // see https://www.elastic.co/guide/en/elasticsearch/guide/current/complex-core-fields.html#object-arrays\n      // and https://www.elastic.co/guide/en/elasticsearch/guide/current/nested-objects.html\n      if(_.isPlainObject(value[0])){\n        Object.keys(value[0]).forEach(function(v){\n          mapSchemaType(v, key);\n        });\n      }else{\n        schemaType = findType(value[0]);\n      }\n\n    }else if(_.isString(value)){\n      schemaType = findType(value);\n    }else{\n      schemaType = findType(value);\n    }\n\n    if(schemaType) {\n      var fieldObj = {\n        type: schemaType,\n        options: typeOptions\n      };\n\n      dot.str(currentPath, fieldObj, results.fields);\n    }\n  }\n\n  return results;\n}\n\nfunction findType(item){\n  var sType;\n  _.forOwn(schemaTypes, function(v, k){\n    if(item === v.jsType || item === v.esType) sType = v;\n  });\n  return sType;\n}\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/schema-types.js":"'use-strict';\n\nvar _ = require('lodash'),\n    utils = require('./utils');\n\nmodule.exports = {\n  ObjectType: ObjectType,\n  StringType: StringType,\n  DateType: DateType,\n  BooleanType: BooleanType,\n  IntegerType: IntegerType,\n  FloatType: FloatType,\n  DoubleType: DoubleType,\n  LongType: LongType,\n  ShortType: ShortType,\n  ByteType: ByteType,\n  BinaryType: BinaryType,\n  GeoPointType: GeoPointType\n};\n\n// MAPPING DOC https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html\n// CORE TYPES https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-core-types.html\n\n// Check the Schema tests for the multiple ways a type can be defined.\n\nfunction Type(options){\n  if(_.isPlainObject(options)){\n    _.assign(this.options, options);\n  }\n}\nType.prototype.toMapping = function(value){\n  return {type: this.constructor.esType };\n};\n\nfunction ObjectType(options){\n  Type.call(this, options);\n}\nutils.inherits(ObjectType, Type);\nObjectType.esType = 'object';\nObjectType.jsType = Object;\nObjectType.compare = _.isPlainObject;\n\n\nfunction StringType(options){\n  Type.call(this, options);\n}\nutils.inherits(StringType, Type);\nStringType.esType = 'string';\nStringType.jsType = String;\nStringType.compare = _.isString;\n\n\nfunction DateType(options){\n  Type.call(this, options);\n}\nutils.inherits(DateType, Type);\nDateType.esType = 'date';\nDateType.jsType = Date;\nDateType.compare = utils.isISO8601;\n\n\nfunction BooleanType(options){\n  Type.call(this, options);\n}\nutils.inherits(BooleanType, Type);\nBooleanType.esType = 'boolean';\nBooleanType.jsType = Boolean;\nBooleanType.compare = _.isBoolean;\n\nfunction NumberType(options){\n  Type.call(this, options);\n}\nutils.inherits(NumberType, Type);\nNumberType.prototype.validate = function(value){\n  if(this.max && value > this.max) return false;\n  if((this.min || this.min ===0) && value < options.min) return false;\n  return this.compare(value);\n};\n\nfunction IntegerType(options){\n  NumberType.call(this, options);\n}\nutils.inherits(IntegerType, NumberType);\nIntegerType.esType = 'integer';\nIntegerType.compare = utils.isInteger;\n\nfunction FloatType(options){\n  NumberType.call(this, options);\n}\nutils.inherits(FloatType, NumberType);\nFloatType.esType = 'float';\nFloatType.compare = utils.isFloat;\n\nfunction DoubleType(options){\n  NumberType.call(this, options);\n}\nutils.inherits(DoubleType, NumberType);\nDoubleType.esType = 'double';\nDoubleType.compare = utils.isFloat;\n\nfunction LongType(options){\n  NumberType.call(this, options);\n}\nutils.inherits(LongType, NumberType)\nLongType.jsType = Number;\nLongType.esType = 'long';\nLongType.compare = utils.isLong;\n\nfunction ShortType(options){\n  NumberType.call(this, options);\n}\nutils.inherits(ShortType, NumberType);\nShortType.esType = 'short';\nShortType.compare = utils.isShort;\n\nfunction ByteType(options){\n  NumberType.call(this, options);\n}\nutils.inherits(ByteType, NumberType);\nByteType.esType = 'byte';\nByteType.compare = utils.isByte;\n\nfunction BinaryType(options){\n  Type.call(this, options);\n}\nutils.inherits(BinaryType, Type);\nBinaryType.esType = 'binary';\nBinaryType.compare = utils.isBase64;\n\nfunction GeoPointType(options){\n  Type.call(this, options);\n}\nutils.inherits(GeoPointType, Type);\nGeoPointType.esType = 'geo_point';\nGeoPointType.compare = utils.isFloat;\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/utils.js":"'use-strict';\n\nvar _ = require('lodash'),\n    nodeUtil = require('util');\n\nmodule.exports = _.extend({\n  forAll: forAll,\n  isISO8601: isISO8601,\n  isBase64: isBase64,\n  isInteger: isInteger,\n  isFloat: isFloat,\n  isShort: isShort,\n  isLong: isLong,\n  isByte: isByte,\n  inRange: inRange,\n  escapeQueryStringQuery: escapeQueryStringQuery\n\n}, nodeUtil);\n\n\nvar expressions = {\n  iso8601: RegExp(/^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24\\:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?/.source + '$'),\n  base64: RegExp(/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?/.source + '$'),\n  float: RegExp(/^[-+]?(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eE][-+]?\\d+)?/.source + '$')\n};\n\nfunction forAll(obj, callback, currentPath) {\n  // calls back for every nested object.\n  if (!currentPath) currentPath = [];\n  if (obj) Object.keys(obj).forEach(compute);\n\n  function compute(key) {\n    var value = obj[key];\n    if (typeof value !== 'object') {\n      callback(currentPath, key, obj);\n    } else {\n      var path = currentPath.slice(0);\n      path.push(key);\n      forAll(value, callback, path);\n    }\n  }\n\n  return void 0;\n}\n\nfunction isISO8601(v) {\n  return expressions.iso8601.test(v);\n}\n\nfunction isBase64(v){\n  return expressions.base64.test(v);\n}\n\nfunction isInteger(v){\n  return typeof v === \"number\" && isFinite(v) && Math.floor(v) === v && inRange(v, -2147483648, 2147483647);\n}\n\nfunction isFloat(v){\n  //return expressions.float.test(v) && !isNaN(parseFloat(v)) && (v%1!=0);\n  // Removed previous line because we need logic to allow numbers without decimals, eg '2' should still be a valid float\n  // Adding temp workaround to allow all numbers as valid floats for now (elasticsearch can coherce anyways)\n   return typeof v === \"number\";\n}\n\nfunction isShort(v){\n  return isInteger(v) && inRange(v, -32768, 32767);\n}\n\nfunction isLong(v){\n  return typeof v === \"number\" && isFinite(v) && Math.floor(v) === v && inRange(v, -9223372036854775808, 9223372036854775807);\n}\n\nfunction isByte(v){\n  return isInteger(v) && inRange(v, -128, 127);\n}\n\nfunction inRange(v, min, max) {\n  return v >= min && v <= max;\n}\n\nfunction escapeQueryStringQuery(query){\nvar regexString,\n    regex;\n\n  // Taken from https://github.com/lanetix/ng-elasticsearch-sanitize/blob/master/src/ng-elastic-escape.js\n  query = query\n    .replace(/([-!(){}\\[\\]^\"~*?:\\+\\/\\\\])/g, '\\\\$1') // replace single character special characters\n    .replace(/(\\|\\|)/g, '\\\\$1') // replace ||\n    .replace(/(\\&\\&)/g, '\\\\$1'); // replace &&\n  _.map(['AND', 'OR', 'NOT'], function (operator) {\n    regexString = 's*\\\\b(' + operator + ')\\\\b\\\\s*'\n    regex = new RegExp(regexString, 'g');\n    query = query.replace(regex,\n      _.map(operator.split(''),\n        function (ch) {\n          return '\\\\' + ch;\n        }\n      ).join('') +' '\n    )\n  });\n  return query;\n}\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/errors.js":"'use-strict';\n\nvar Promise = require('bluebird'),\n    utils = require('./utils');\n\nfunction ElasticsearchError(message){\n  this.message = message;\n  this.stack = new Error().stack;\n  this.name = 'ElasticsearchError';\n}\n\nutils.inherits(ElasticsearchError, Error);\n\nmodule.exports = exports = ElasticsearchError;\n\nElasticsearchError.ConnectionError = require('./errors/connection');\nElasticsearchError.ValidatorError = require('./errors/validator');\nElasticsearchError.ValidationError = require('./errors/validation');\nElasticsearchError.MissingArgumentError = require('./errors/missing-argument');\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/errors/connection.js":"'use-strict';\n\nvar ElasticsearchError = require('../errors.js'),\n    utils = require('../utils');\n\nfunction ConnectionError(host){\n  var message;\n  if(host){\n    message = 'No connection can be established to Elasticsearch at ' + host;\n  }else{\n    message = 'No connection has been established to Elasticsearch.';\n  }\n  ElasticsearchError.call(this, message);\n  if(Error.captureStackTrace) Error.captureStackTrace(this, arguments.callee);\n  this.name = 'ConnectionError';\n  this.host = host || '';\n}\n\nutils.inherits(ConnectionError, ElasticsearchError);\n\nmodule.exports = ConnectionError;\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/errors/validator.js":"'use-strict';\n\nvar ElasticsearchError = require('../errors.js'),\n    utils = require('../utils');\n\nfunction ValidatortError(property, reason){\n  var message = \"Validator failed for property '\"+ property + \"'\";\n  if(reason) message = message + \" \" + reason;\n\n  ElasticsearchError.call(this, message);\n  if(Error.captureStackTrace) Error.captureStackTrace(this, arguments.callee);\n  this.name = 'ValidatorError';\n  this.property = property;\n}\n\nutils.inherits(ValidatortError, ElasticsearchError);\n\nmodule.exports = ValidatortError;\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/errors/validation.js":"'use-strict';\n\nvar ElasticsearchError = require('../errors.js'),\n    utils = require('../utils');\n\nfunction ValidationError(instance, errors) {\n  ElasticsearchError.call('Validation failed');\n  this.stack = new Error().stack;\n  this.name = 'ValidationError';\n  this.errors = errors || [];\n}\n\nutils.inherits(ValidationError, ElasticsearchError);\n\nValidationError.prototype.toString = function () {\n  var ret = this.name + ': ';\n  var msgs = [];\n\n  Object.keys(this.errors).forEach(function (key) {\n    if (this == this.errors[key]) return;\n    msgs.push(String(this.errors[key]));\n  }, this);\n\n  return ret + msgs.join(', ');\n};\n\nmodule.exports = ValidationError;\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/errors/missing-argument.js":"'use-strict';\n\nvar ElasticsearchError = require('../errors.js'),\n    utils = require('../utils');\n\nfunction MissingArgumentError(path){\n  ElasticsearchError.call(this, 'Missing argument \"' + path + '\".');\n  if(Error.captureStackTrace) Error.captureStackTrace(this, arguments.callee);\n  this.name = 'MissingArgumentError';\n  this.path = path;\n}\n\nutils.inherits(MissingArgumentError, ElasticsearchError);\n\nmodule.exports = MissingArgumentError;\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/model.js":"'use strict';\n\nvar  _ = require('lodash'),\n    Promise = require('bluebird');\n\nfunction Model(document) {\n  var self = this;\n  _.assign(self, document);\n\n  Object.defineProperty(self, 'isNew', {\n    value: !document || !document.id,\n    configurable: false,\n    writable: true\n  });\n}\n\nModel.prototype.execPreHook = function(name, context) {\n  var self = this;\n  return new Promise(function(resolve, reject){\n    if(self.constructor.model.schema && self.constructor.model.schema.hooks){\n      self.constructor.model.schema.hooks.execPre(name, context, function(err) {\n        return err ? reject(err) : resolve();\n      });\n    }else{\n      return resolve();\n    }\n  });\n};\n\nModel.prototype.execPostHook = function(name, context) {\n  var self = this;\n  if(self.constructor.model.schema && self.constructor.model.schema.hooks){\n    self.constructor.model.schema.hooks.execPost(name, null, [context], function(){\n      // null callback for post hooks, like mongoose.\n    });\n  }\n  return void 0;\n};\n\nModel.prototype.validate = function(doc, partial) {\n  if(this.constructor.model.schema){\n    return this.constructor.model.schema.validate(doc, partial);\n  }\n};\n\nModel.prototype.toObject = function() {\n  return _.cloneDeep(this);\n};\n\nModel.prototype.toJSON = function() {\n  return this.toObject();\n};\n\nModel.prototype.set = function(data, options) {\n  var self = this;\n\n  if(self.isNew){\n    // User should be calling .save() insead, so redirect them.\n    _.assign(self, data);\n    return self.save();\n  }\n\n  var document = self.toObject();\n\n  // Add any required keys to the new data.\n  _.assign(data, {\n    id: self.id,\n    createdOn: self.createdOn,\n    updatedOn: self.updatedOn,\n  });\n\n  // Find out any removed keys and delete them from current instance\n  // and the document to be sent.\n  var currentKeys = Object.keys(document);\n  var newKeys = Object.keys(data);\n  var deletedKeys = _.difference(currentKeys, newKeys);\n  _.forEach(deletedKeys, function(k){\n    delete self[k];\n    delete document[k];\n  });\n\n  // Now we can assign the object to be sent.\n  _.assign(document, data);\n\n  return self.constructor.set(self.id, document, options)\n  .then(function(result) {\n    return _.assign(self, result);\n  });\n};\n\nModel.prototype.save = function(options) {\n  var self = this;\n\n  if(!self.isNew){\n    return self.update(self.toObject());\n  }\n\n  if(self.id){\n    // If the user is trying to create a new model with a forced id,\n    // then this only acts as an alias to the .set() function.\n    return self.constructor.set(self.toObject(), options);\n  }\n\n  return self.execPreHook('save', self)\n  .then(function(){\n    var document = self.toObject();\n\n    // Schemas aren't requried, so check if it's defined.\n    if(self.constructor.model.schema){\n      var errors = self.validate(document);\n      if(errors) return Promise.reject(errors);\n    }\n\n    return self.constructor.create(document, options);\n  })\n  .then(function(result) {\n    self.isNew = false;\n    _.assign(self, result);\n    self.execPostHook('save', self);\n    return self;\n  });\n};\n\nModel.prototype.update = function(data, options) {\n  var self = this;\n\n  // Schemas aren't requried, so check if it's defined.\n  if(self.constructor.model.schema){\n    var document = _.assign({}, self.toObject(), data);\n    var errors = self.validate(document, true);\n    if(errors) return Promise.reject(errors);\n  }\n\n  return self.constructor.update(self.id, data, options)\n  .then(function(result) {\n    self.isNew = false;\n    return _.assign(self, result);\n  });\n};\n\nModel.prototype.remove = function() {\n  var self = this;\n  return self.execPreHook('remove', self)\n  .then(function(){\n    return self.constructor.remove(self.id);\n  })\n  .then(function(){\n    // don't pass instances to post remove hook, only Objects.\n    // also make sure to pass the document before we remove it's id.\n    self.execPostHook('remove', self.toObject());\n    delete self.id;\n    delete self._id;\n    self.isNew = true;\n    return self;\n  });\n};\n\nmodule.exports = Model;\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/default-methods.js":"'use-strict';\n\nvar Query = require('./query'),\n    errors = require('./errors'),\n    MissingArgumentError = errors.MissingArgumentError,\n    Promise = require('bluebird'),\n    _ = require('lodash');\n\nmodule.exports = {\n\n  count: function() {\n    return this.db.client.count({\n      index: this.db.index,\n      type: this.model.type,\n    });\n  },\n\n  create: function(data, options) {\n    options = options || {};\n    if (!data) return Promise.reject(new MissingArgumentError('data'));\n    data.createdOn = data.createdOn = new Date().toISOString();\n    data.updatedOn = data.updatedOn = new Date().toISOString();\n\n    var self = this;\n    return self.db.client.create({\n      index: self.db.index,\n      type: self.model.type,\n      body: data,\n      refresh: false, // dont use refresh here, as it's refresh when we update with id.\n    })\n    .then(function(result) {\n      return self.update(result._id, {id: result._id}, options);\n    });\n  },\n\n  update: function(id, data, options) {\n    options = options || {};\n    if (!id) return Promise.reject(new MissingArgumentError('id'));\n    if (!data) return Promise.reject(new MissingArgumentError('data'));\n\n    data.updatedOn = new Date().toISOString();\n\n    var self = this;\n    return self.db.client.update({\n      index: self.db.index,\n      type: self.model.type,\n      id: id,\n      refresh: options.refresh || false,\n      body: {\n        doc: data\n      }\n    })\n    .then(function(res) {\n      return self.findById(id);\n    });\n  },\n\n  search: function(queryOptions, query){\n    var self = this;\n    return self.db.client.search(query).then(function(results) {\n\n      results = Query.parseResponse(queryOptions, query, results);\n      // is this a pages request or normal?\n      if (queryOptions && (queryOptions.page || queryOptions.per_page)) {\n        if (results.hits.length) {\n          results.hits = self.makeInstance(results.hits);\n        }\n      } else {\n        results = self.makeInstance(results);\n        // this method will always return an array.\n        if (!_.isArray(results)) results = [results];\n      }\n      return results;\n    });\n  },\n\n  find: function(match, queryOptions) {\n    var self = this;\n    queryOptions = _.isPlainObject(queryOptions) ? queryOptions : {};\n    var query = Query.parseRequest(self.db.index, self.model.type, match, queryOptions);\n\n    return new Query.QueryPromise(query, function(q){\n      return self.search(queryOptions, q);\n    });\n  },\n\n  findAndRemove: function(match, queryOptions, options) {\n    if( _.isEmpty(match) && _.isEmpty(queryOptions) ) return Promise.reject(new MissingArgumentError('match'));\n\n    options = _.isPlainObject(options) ? options : {};\n    queryOptions = _.isPlainObject(queryOptions) ? queryOptions : {};\n    queryOptions = _.pick(queryOptions, ['q', 'must', 'not', 'exists', 'missing']);\n    queryOptions.fields = 'id';\n\n    var self = this;\n    // we could use elasticsearchs deleteByQuery() but it will be deprecated in version 2\n    // so we just fetch all id's, and run a normal delete query on then.\n    return self.find(match, queryOptions).then(function(results) {\n      if (!results || !results.length) return [];\n\n      var bulkOps = _.chain(results)\n        .each()\n        .map(function(v) {\n          return {\n            'delete': {\n              '_index': self.db.index,\n              '_type': self.model.type,\n              '_id': v.id\n            }\n          };\n        })\n        .value();\n\n      return self.db.client.bulk({body: bulkOps, refresh: options.refresh || false});\n    });\n  },\n\n  findById: function(id, queryOptions) {\n    if (!id) return Promise.reject(new MissingArgumentError('id'));\n\n    var self = this;\n    queryOptions = _.isPlainObject(queryOptions) ? queryOptions : {};\n\n    var func = function(query){\n      return self.db.client.getSource(query)\n      .then(function(results) {\n        return self.makeInstance(results);\n      });\n    };\n    queryOptions.id = id;\n\n    var query = Query.parseRequest(self.db.index, self.model.type, null, queryOptions);\n    // get requests shouldn't include a body;\n    delete query.body;\n    return new Query.QueryPromise(query, func);\n  },\n\n  findByIds: function(ids, queryOptions) {\n    if (!ids) return Promise.reject(new MissingArgumentError('ids'));\n    if (_.isString(ids)) return self.findById(ids, queryOptions);\n\n    var self = this;\n    queryOptions = _.isPlainObject(queryOptions) ? queryOptions : {};\n    queryOptions.ids = ids;\n\n    var query = Query.parseRequest(self.db.index, self.model.type, null, queryOptions);\n\n    return new Query.QueryPromise(query, function(q){\n      return self.search(queryOptions, q);\n    });\n  },\n\n  findOne: function(match, queryOptions) {\n    if( _.isEmpty(match) && _.isEmpty(queryOptions) ) return Promise.reject(new MissingArgumentError('match'));\n\n    var self = this;\n    queryOptions = _.isPlainObject(queryOptions) ? queryOptions : {};\n    // Safe default, assuming many matches return the newest.\n    queryOptions.sort = queryOptions.sort || '-createdOn';\n    queryOptions.page = 0;\n    queryOptions.per_page = 1;\n    var func = function(query){\n      return self.search(queryOptions, query).then(function(results) {\n        if (results && results.hits && results.hits.length) {\n          return results.hits[0];\n        } else {\n          return void 0;\n        }\n      });\n    };\n\n    var query = Query.parseRequest(self.db.index, self.model.type, match, queryOptions);\n\n    return new Query.QueryPromise(query, func);\n  },\n\n  findOneAndRemove: function(match, queryOptions, options) {\n    if (_.isEmpty(match)) return Promise.reject(new MissingArgumentError('match'));\n\n    var self = this;\n    queryOptions = _.isPlainObject(queryOptions) ? queryOptions : {};\n    options = _.isPlainObject(options) ? options : {};\n\n    return self.findOne(match, queryOptions).then(function(results) {\n      if(results && results.id){\n        return self.remove(results.id, options).then(function(){\n          return results;\n        })\n      }else{\n          return [];\n      }\n    });\n  },\n\n  remove: function(id, options) {\n    options = options || {};\n    if (!id) return Promise.reject(new MissingArgumentError('id'));\n\n    return this.db.client.delete({\n      index: this.db.index,\n      refresh: options.refresh || false,\n      type: this.model.type,\n      id: id\n    });\n  },\n\n  removeByIds: function(ids) {\n    if (!ids) return Promise.reject(new MissingArgumentError('ids'));\n\n    return this.findAndRemove({id: ids});\n  },\n\n  set: function(id, document, options) {\n    if (!id) return Promise.reject(new MissingArgumentError('id'));\n    if (!document) return Promise.reject(new MissingArgumentError('document'));\n\n    var self = this;\n    options = _.isPlainObject(options) ? options : {};\n\n    // just to be safe, force id.so it's not removed.\n    document.id = id;\n\n    return self.db.client.index({\n      index: self.db.index,\n      type: self.model.type,\n      id: id,\n      refresh: options.refresh || false,\n      body: document\n    })\n    .then(function() {\n      return self.makeInstance(document);\n    });\n  },\n\n  makeInstance: function(documents) {\n    var self = this;\n    if (!documents) return Promise.reject(new MissingArgumentError('documents'));\n\n    var make = function(document) {\n      return new self.model.constructor(document || {});\n    };\n\n    if (_.isArray(documents)) {\n      var models = [];\n      _.forEach(documents, function(document) {\n        models.push(make(document));\n      });\n      return models;\n    } else {\n      return make(documents);\n    }\n  },\n\n  toMapping: function() {\n    // toMapping is only for models with schemas\n    if(!this.model.schema) return void 0;\n\n    var mapping = {};\n    mapping[this.model.type] = {};\n    _.assign(mapping[this.model.type], this.model.schema.toMapping());\n    return mapping;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-elasticsearch-odm/node_modules/elasticsearch-odm/lib/query.js":"'use strict';\n\nvar _ = require('lodash'),\n    logger = require('./logger'),\n    utils = require('./utils'),\n    dot = require('dot-object');\n\nmodule.exports = {\n  QueryPromise: QueryPromise,\n\n  parseRequest: parseRequest,\n  parseResponse: parseResponse,\n\n  addTermFilters:  addTermFilters,\n  addPagination: addPagination,\n  addSorts: addSorts,\n  addPopulations: addPopulations,\n  addExistenceFilters: addExistenceFilters\n};\n\nfunction QueryPromise(query, func){\n  // We wrap a promise for the query. To allow chaining of methonds\n  // in between the 'then-able'. func argument takes a single query argument\n  // and returns a promise that is resolved with the found document.\n  // This allows calls like, .find().sort().then(...)\n\n  var self = this;\n  self.q = _.cloneDeep(query);\n  self.p = {\n    resolve: function(){},\n    reject: function(){}\n  };\n  self.isExecuted = false;\n\n  self._exec = function(){\n    if(!self.isExecuted){\n      self.isExecuted = true;\n\n      /**\n      if(self.q.body){;\n        process.nextTick(function(){\n          console.log(utils.inspect(self.q.body.query.filtered, { showHidden: true, depth: null }));\n        });\n      }\n      */\n\n      func(self.q)\n      .then(function(res){\n        self.p.resolve(res);\n      })\n      .catch(function(err){\n        self.p.reject(err);\n      });\n    }\n  };\n\n  self.then = function(resolve, reject){\n    var promise = new Promise(function(success, error){\n      self.p.resolve = success;\n      self.p.reject = error;\n      self._exec();\n    });\n\n    return promise.then(resolve, reject);\n  };\n\n  self.populate = function(value){\n    addPopulations(self.q, value);\n    return self;\n  };\n\n  self.must = function(value){\n    addTermFilters(self.q, value);\n    return self;\n  };\n\n  self.missing = function(value){\n    addExistenceFilters(self.q, value);\n    return self;\n  };\n\n  self.exists = function(value){\n    addExistenceFilters(self.q, null, value);\n    return self;\n  };\n\n  self.not = function(value){\n    addTermFilters(self.q, null, value);\n    return self;\n  };\n\n  self.sort = function(value){\n    addSorts(self.q, value);\n    return self;\n  };\n\n  // If .then() is never called, make sure we execute the query.\n  // This allows the '.findAndRemove' type queries to still work\n  // even when .then() is never called.\n  process.nextTick(function(){\n    self._exec();\n  });\n}\n\nfunction PagedResponse(data){\n  var self = this;\n  _.assign(self, data);\n}\nPagedResponse.prototype.toObject = function(){\n  return {\n    total: this.total,\n    hits: _.map(this.hits, function(h){return h.toObject(); }),\n    page: this.page,\n    pages: this.pages\n  };\n};\n\nPagedResponse.prototype.toJSON = function(){\n  return this.toObject();\n};\n\nfunction parseRequest(indices, types, matches, options){\n  options = options || {};\n  var req = {\n    index: indices,\n    type: types,\n    body: {\n      query: {match_all: {}}\n    }\n  };\n\n  var allowedOptions = [];\n\n  if(options.id){\n    allowedOptions = [\n      'id',\n      'fields',\n      'populate'\n    ];\n  }else if(options.ids){\n    allowedOptions = [\n      'ids',\n      'fields',\n      'populate',\n      'sort',\n      'page',\n      'per_page'\n    ];\n  }else{\n    allowedOptions = [\n      'missing',\n      'exists',\n      'must',\n      'not',\n      'fields',\n      'sort',\n      'page',\n      'per_page',\n      'q',\n      'populate'\n    ];\n  }\n  options = _.pick(options, allowedOptions);\n\n  if(options.id) req.id = options.id;\n  if(options.ids) {\n    req.body.query = {\n      ids: {\n        values: options.ids\n      }\n    };\n  }\n\n  if(!_.isEmpty(matches)){\n    if(_.isString(matches)) options.q = matches;\n    if(_.isPlainObject(matches)) options.must = _.merge({}, options.must, matches);\n  }\n\n  if(options.q && _.isString(options.q)){\n    // escape any special characters in the query string\n    // see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html\n    options.q = utils.escapeQueryStringQuery(options.q);\n    req.body.query = { query_string: {query: options.q} };\n  }\n\n  if(options.fields){\n    req.body.fields = _.isArray(options.fields) ? options.fields : [options.fields];\n  }\n\n  if(options.sort){\n    addSorts(req, options.sort);\n  }\n\n  if(options.page || options.per_page){\n    addPagination(req, options.page, options.per_page);\n  }\n\n  if(options.must || options.not){\n    addTermFilters(req, options.must, options.not, options.missing, options.exists);\n  }\n\n  if(options.missing || options.exists){\n    addExistenceFilters(req, options.missing, options.exists);\n  }\n\n  if(!req.hasOwnProperty('size')) {\n    // NOTE: we use a high number as our default to return everything\n    // because mongoose also does so.\n    req.size = 999999;\n    req.from = 0;\n  }\n\n  return req;\n}\n\nfunction parseResponse(options, query, res){\n  if(query.body && query.body.fields){\n    // elasticsearch wraps field queries in its own body, so we clean it up a bit.\n    // all in the name of an easy to use API\n    res.hits.hits = _.chain(res.hits.hits)\n      .pluck('fields')\n      .map(function(_v){\n        return _.map(_v, function(v, k){\n          var item = {};\n          if(_.isArray(v) && v.length === 1){\n            item[k] = v[0];\n          }else{\n            item[k] = v;\n          }\n          return item;\n        });\n      })\n      .flatten()\n      .value();\n  }\n\n  // if _source exists, set the item as _source\n  res.hits.hits = _.map(res.hits.hits, function(v){\n    return v._source || v;\n  });\n\n  if(options && (options.page || options.per_page)){\n    return new PagedResponse({\n      total: res.hits.total,\n      hits: res.hits.hits,\n      page: options.page,\n      pages: Math.ceil(res.hits.total / query.size)\n    });\n  }else{\n    return res.hits.hits;\n  }\n\n}\n\nfunction addExistenceFilters(req, missingFilters, existsFilters){\n  // see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-missing-filter.html\n  // and https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-filters.html\n\n  // is this a filtered query, or a regulat?\n  var boolFilter = dot.pick('body.query.filtered', req);\n\n  var getPreviousFilters = function(){\n    var andFilters;\n    if(boolFilter){\n      andFilters = dot.pick('body.query.filtered.query.constant_score.filter.and', req);\n    }else{\n      andFilters = dot.pick('body.query.constant_score.filter.and', req);\n    }\n    return andFilters || [];\n  };\n\n  var query = {\n    constant_score: {\n      filter: {\n        and: getPreviousFilters()\n      }\n    }\n  };\n\n  var makeFilter = function(name, filters){;\n    if(filters){\n      filters = _.isArray(filters) ? filters : [filters];\n      _.forEach(filters, function(v){\n        var f = {};\n        f[name] = {field: v};\n        query.constant_score.filter.and.push(f);\n      });\n    }\n  };\n\n  makeFilter('missing', missingFilters);\n  makeFilter('exists', existsFilters);\n\n  if(boolFilter){\n    req.body.query.filtered.query = query;\n  }else{\n    req.body.query = query;\n  }\n}\n\nfunction addTermFilters(req, mustFilters, notFilters){\n  var filter = {\n    bool: {\n      must: [],\n      must_not: []\n    }\n  };\n\n  var makeTermFilter = function(v, k){\n    var f = {};\n    if(_.isArray(v)){\n      f.terms = {};\n      f.terms[k] = v;\n    }else{\n      f.term = {};\n      f.term[k] = v;\n    }\n    return f;\n  };\n\n  filter.bool.must = _.map(mustFilters, makeTermFilter);\n  filter.bool.must_not = _.map(notFilters, makeTermFilter);\n\n  // Remove any empty filters, Elasticsearch will throw an error.\n  _.each(filter.bool, function(v, k) {\n    if(!v || !v.length) delete filter.bool[k];\n  });\n\n  // No filters found? return now.\n  if(_.isEmpty(filter.bool)) return void 0;\n\n  // Is this a new filtered query, or an existing to merge with?\n  var boolFilter = dot.pick('body.query.filtered.filter.bool', req);\n\n  var mergeFilter = function(filterName, data){\n    if( _.isArray(boolFilter[filterName]) ){\n      req.body.query.filtered.filter.bool[filterName] = req.body.query.filtered.filter.bool[filterName].concat(data);\n    }else if( _.isPlainObject(boolFilter[filterName]) ){\n      req.body.query.filtered.filter.bool[filterName] = [boolFilter[filterName]];\n      req.body.query.filtered.filter.bool[filterName] = req.body.query.filtered.filter.bool[filterName].concat(data);\n    }else{\n      req.body.query.filtered.filter.bool[filterName] = data;\n    }\n  };\n\n  if(boolFilter){\n    if(filter.bool.must) mergeFilter('must', filter.bool.must);\n    if(filter.bool.must_not) mergeFilter('must_not', filter.bool.must_not);\n  }else{\n    req.body.query = {\n      filtered: {\n        query: req.body.query,\n        filter: filter\n      }\n    };\n  }\n\n  ///Pretty sure elasticsearch doesn't allow arrays for 'must' when only one rule is added.\n  if(req.body.query.filtered.filter.bool.must\n    && req.body.query.filtered.filter.bool.must.length === 1){\n    req.body.query.filtered.filter.bool.must = req.body.query.filtered.filter.bool.must[0];\n  }\n  if(req.body.query.filtered.filter.bool.must_not && req.body.query.filtered.filter.bool.must_not.length === 1){\n    req.body.query.filtered.filter.bool.must_not = req.body.query.filtered.filter.bool.must_not[0];\n  }\n\n}\n\nfunction addPagination(req, page, per_page){\n  if(!page && !per_page) return void 0;\n  page = isNaN(parseInt(page)) || (page <= 0) ? 1 : parseInt(page);\n  per_page = isNaN(parseInt(per_page)) || (per_page <= 1) ? 10 : parseInt(per_page);\n  req.from =  (page - 1) * per_page;\n  req.size = per_page;\n}\n\nfunction addSorts(req, sorts){\n  sorts = _.isString(sorts) ? [sorts] : sorts;\n\n  var result = {\n    sort: []\n  };\n\n  var makeSort = function(sort){\n    var item = {}, order;\n    if(_.startsWith(sort, '-')){\n      sort = sort.substring(1);\n      order = 'desc';\n    }else{\n      order = 'asc';\n    }\n    item[sort] = {order: order, ignore_unmapped: true};\n    return item;\n  };\n\n  result.sort = _.map(sorts, makeSort);\n\n  if(result.sort.length === 1){\n    result.sort = result.sort[0];\n  }\n\n  if(_.isArray(req.body.sort)){\n    req.body.sort = req.body.sort.concat(result.sort);\n  }else{\n    req.body.sort = result.sort;\n  }\n}\n\nfunction addPopulations(req, value){\n  if(!req.populate) req.populate = [];\n  req.populate.push(value);\n}\n"}